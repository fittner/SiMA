/**
 * E6_DefenseMechanismsForDriveContents.java: DecisionUnits - pa.modules
 * 
 * @author gelbard
 * 30.11.2011, 14:01:06
 */
package primaryprocess.modules;

import inspector.interfaces.itfInspectorBarChartF06;
import inspector.interfaces.itfInspectorCombinedTimeChart;
import inspector.interfaces.itfInspectorModificationDrives;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.SortedMap;

import memorymgmt.enums.eContent;
import memorymgmt.enums.eContentType;
import memorymgmt.enums.eDataType;
import memorymgmt.enums.eEmotionType;
import memorymgmt.storage.DT2_BlockedContentStorage;
import modules.interfaces.D2_3_send;
import modules.interfaces.I5_13_receive;
import modules.interfaces.I5_17_receive;
import modules.interfaces.I5_17_send;
import modules.interfaces.I5_18_receive;
import modules.interfaces.I5_18_send;
import modules.interfaces.I5_22_receive;
import modules.interfaces.I5_5_receive;
import modules.interfaces.eInterfaces;
import base.datahandlertools.clsDataStructureGenerator;
import base.datatypes.clsAffect;
import base.datatypes.clsAssociation;
import base.datatypes.clsDataStructurePA;
import base.datatypes.clsDriveMesh;
import base.datatypes.clsEmotion;
import base.datatypes.clsPrimaryDataStructure;
import base.datatypes.clsPrimaryDataStructureContainer;
import base.datatypes.clsThingPresentation;
import base.datatypes.clsThingPresentationMesh;
import base.datatypes.enums.eDriveComponent;
import base.datatypes.helpstructures.clsPair;
import base.datatypes.helpstructures.clsTriple;
import base.modules.clsModuleBase;
import base.modules.eImplementationStage;
import base.modules.eProcessType;
import base.modules.ePsychicInstances;
import base.tools.toText;
import primaryprocess.functionality.superegofunctionality.clsSuperEgoConflict;
import properties.clsProperties;
import properties.personality_parameter.clsPersonalityParameterContainer;
import base.datatypes.helpstructures.clsQuadruppel;

/**
 * Defends forbidden drives. Super-Ego (F7 and F55) sends a list with forbidden drives to F06. F06 decides whether to 

defend the forbidden drives or not.
 * If F06 decided to defend the forbidden drives F06 chooses the defense mechanism (repression, sublimation, displacement, 

...).
 * 
 * The following defense mechanisms for drives are implemented:
 * - repression (Verdrängung)
 * - reaction formation< (Reaktionsbildung: new drive aim = opposite of old drive aim)
 * - displacement (Verschiebung: Drive object is changed) 
 * - sublimation (new drive aim is a social and cultural higher drive aim) 
 * - intellectualization (new drive aim is an intellectual drive aim) - TODO: drive aims müssen noch definiert werden
 * - Turning against Self is defined that the new Drive Object is "Self"
 * - Projection is defined that the new Drive Source is the old Drive Object and new Drive object is Self
     Since Drive Source in ARS is Organ we use projection to protect ARSIN From  Turning against self if drive aim such as EAT and Bite
 * 
 * @author gelbard and Lotfi
 * 07.05.2012, 14:01:06
 * 25.06.2013, 21
 * 
 */
public class F06_DefenseMechanismsForDrives extends clsModuleBase implements 
					I5_5_receive, I5_13_receive, I5_18_send, I5_17_send, D2_3_send, I5_22_receive, itfInspectorBarChartF06,itfInspectorCombinedTimeChart,itfInspectorModificationDrives {
	public static final String P_MODULENUMBER = "06";

	public static final String P_INTENSITY_REDUCTION_RATE_SELF_PRESERV = "INTENSITY_REDUCTION_RATE_SELF_PRESERV";
	   
	private ArrayList<clsDriveMesh> moDriveList_Input;
	private ArrayList<clsDriveMesh> moDriveList_Output;
	
	private double moEgoStrength; // personality parameter to adjust the strength of the Ego
	
	private ArrayList<clsSuperEgoConflict> moForbiddenDrives_Input;
	private ArrayList<clsPrimaryDataStructureContainer> moRepressedRetry_Input;
	private ArrayList<clsDriveMesh> moSexualDrives;
//	private ArrayList<String>Test =new ArrayList<String>();
//	private ArrayList<String>Test1 =new ArrayList<String>();
	private String oOriginalDOContentForTurning_Against_Self= new String();
	 
	HashMap<String, Double>  moTimeChartData = new HashMap<String, Double>(); 

	private ArrayList<clsPrimaryDataStructure> moQuotasOfAffect_Output = new ArrayList<clsPrimaryDataStructure>();  // anxiety which is generated while repressing content

	// defense mechanisms must be activated by a psychoanalytic conflict
	// defense_active symbolizes an unpleasure value which is generated by the psychonanlytic conflict
	boolean defense_active = false;
	
	private HashMap<String, String> oOppositeTP = new HashMap<String, String> ();
	
	//Ivy
	private ArrayList <clsQuadruppel<String, String, String, Double>> smile = new ArrayList <clsQuadruppel<String, String, String, Double>> (); //DriveAim, DriveObject, ChartsShortString, QoA
	private ArrayList <clsChangedDrives> mDisplayDrives = new ArrayList <clsChangedDrives> ();
	private int nStep = 0;
	
	public class clsChangedDrives {
	    
	    
	   //////// überprüfen ob alles eingegeben wurde oder ob, also wird eh eine fillafterChange aufgerufen??
	    /// funktion erstellen die die clsPair vergleicht
	    private clsPair <String, String> oDriveAim; //vorher, nachher
	    private clsPair <String, String> oDriveObject;
	    private clsPair <Double, Double> nQoA;
	    private String oMotivation;
	    private String oDefense;
	    int nStep;
	    ///
	    private String tDriveAim, tDriveObject;
	    Double tQoA;
	    private boolean bfillAfter = false;
	    
	    public clsChangedDrives () {

	    }
	    private void fillBeforeChange (String driveaim, String driveobject, Double QoA, String motivation, String defense, int step) {
	        tDriveAim = driveaim;
	        tDriveObject = driveobject;
	        tQoA = QoA;
	        oMotivation = motivation;
	        oDefense = defense;
	        nStep = step;
	        
	        bfillAfter = true;
	    }
	    private void fillAfterChange (String driveaim, String driveobject, Double QoA) {
	        
//	        if (bfillAfter)
	        oDriveAim = new clsPair <String, String> (tDriveAim, driveaim);
	        oDriveObject = new clsPair <String, String> (tDriveObject, driveobject);
	        nQoA = new clsPair <Double, Double> (tQoA, QoA);
	        
	        tDriveAim = "";
            tDriveObject = "";
            tQoA = 0.0;
            
            bfillAfter = false;
	    }
	    ///////////////////////////////
	    public clsPair <String, String> getDriveAim () {
	        return oDriveAim;
	    }
	    public clsPair <String, String> getDriveObject () {
            return oDriveObject;
        }
	    public clsPair <Double, Double> getQoA () {
	        return nQoA;
	    }
	    public String getMotivation () {
	        return oMotivation;
	    }
	    public String getDefense () {
            return oDefense;
        }
	    public int getStep () {
            return nStep;
        }
	    public boolean getBFiller () {
	        return bfillAfter;
	    }
	    ///////////////////////////////
	    public boolean compare () {
	        return true;
	    }
	    
	    
	}
	
	ArrayList <clsChangedDrives> bla;
	
	
	
	//Ivy-|
	
	
	private ArrayList<clsEmotion> moEmotions_Input; 
	private ArrayList<clsEmotion> moEmotions_Output;
	
	/**********For TimeChart And BarChart********************/
	Double TimeDisplacement=0.0;
	Double Displacement=0.0;
	Double ReactionFormation =0.0;
	Double TimeReactionFormation =0.0;
	Double ReversalOfAffect =0.0;
	Double TimeReversalOfAffect =0.0;
	Double TimeRepression=0.0;
	Double Repression=0.0;
	Double Sublimation=0.0;
	Double TimeSublimation=0.0;
	Double PassForbiddenDrives=0.0;
	Double TimePassForbiddenDrives=0.0;
	Double Turning_Against_Self=0.0;
	Double TimeTurning_Against_Self=0.0;
	Double TimeProjection=0.0;
	Double Projection=0.0;
	/************************************************/
	

	
	private DT2_BlockedContentStorage moBlockedContentStorage; // storage for repressed drives and denied perceptions

	/** 
	* 
	* @author gelbard
	* 15.09.2011, 16:38:57
	*
	* @param poPrefix
	* @param poProp
	* @param poModuleList
	* @param poInterfaceData
	* @param poBlockedContentStorage
	* @throws Exception
	*/
   public F06_DefenseMechanismsForDrives(String poPrefix, clsProperties poProp, HashMap<Integer,
		   clsModuleBase> poModuleList, SortedMap<eInterfaces, ArrayList<Object>> poInterfaceData,
		   DT2_BlockedContentStorage poBlockedContentStorage,
		   clsPersonalityParameterContainer poPersonalityParameterContainer)
		   throws Exception {
	    super(poPrefix, poProp, poModuleList, poInterfaceData);
	    moBlockedContentStorage = poBlockedContentStorage;

	    applyProperties(poPrefix, poProp);
	    
        // for use case 1: the Ego strength is equal to the neutralization rate
        // (normalerweise wird sie über receive_I5_22 empfangen - siehe vorletzte Zeile in diesem File)
        moEgoStrength  = poPersonalityParameterContainer.getPersonalityParameter("F56", P_INTENSITY_REDUCTION_RATE_SELF_PRESERV).getParameterDouble();
	    
	    moTimeChartData =  new HashMap<String, Double>();
	}


	/* (non-Javadoc)
	*
	* @author gelbard
	* 15.09.2011, 17:36:19
	* 
	* @see pa.modules._v38.clsModuleBase#stateToTEXT()
	*/
	@Override
    public String stateToTEXT() {
		String text ="";
		
		text += toText.valueToTEXT("moDriveList_Input", moDriveList_Input);
		text += toText.valueToTEXT("moDriveList_Output", moDriveList_Output);
//		text += toText.valueToTEXT("Test1", Test1);
//		text += toText.valueToTEXT("Test", Test);
		
		
		text += toText.listToTEXT("moRepressedRetry_Input", moRepressedRetry_Input);
		text += toText.listToTEXT("moForbiddenDrives_Input", moForbiddenDrives_Input);
		text += toText.listToTEXT("moSexualDrives", moSexualDrives);
		text += toText.listToTEXT("moQuotasOfAffect_Output", moQuotasOfAffect_Output);
		text += toText.valueToTEXT("moBlockedContentStorage", moBlockedContentStorage);
		text += toText.listToTEXT("moEmotions_Input", moEmotions_Input);
		text += toText.listToTEXT("moEmotions_Output", moEmotions_Output);
		
		
		
		
		
		return text;
	}

	public static clsProperties getDefaultProperties(String poPrefix) {
		String pre = clsProperties.addDot(poPrefix);
		
		clsProperties oProp = new clsProperties();
		oProp.setProperty(pre+P_PROCESS_IMPLEMENTATION_STAGE, eImplementationStage.BASIC.toString());
		
		return oProp;
	}	

	private void applyProperties(String poPrefix, clsProperties poProp) {
		//String pre = clsProperties.addDot(poPrefix);
		
		//PassForbiddenDrives to do
	}
	
	/* (non-Javadoc)
	*
	* @author deutsch
	* 11.08.2009, 12:09:34
	* 
	* @see pa.modules.clsModuleBase#setProcessType()
	*/
	@Override
	protected void setProcessType() {
		mnProcessType = eProcessType.PRIMARY;
	}
	
	/* (non-Javadoc)
	*
	* @author deutsch
	* 11.08.2009, 12:09:34
	* 
	* @see pa.modules.clsModuleBase#setPsychicInstances()
	*/
	@Override
	protected void setPsychicInstances() {
		mnPsychicInstances = ePsychicInstances.EGO;
	}
	
	/* (non-Javadoc)
	*
	* @author deutsch
	* 11.08.2009, 13:46:50
	* 
	* @see pa.interfaces.I1_3#receive_I1_3(int)
	*/
	@Override
	public void receive_I5_5(ArrayList<clsDriveMesh> poData) {
	
	}

	/* Input from Super-Ego = E7
	*
	* @author deutsch
	* 11.08.2009, 14:07:30
	* 
	* @see pa.interfaces.I3_1#receive_I3_1(int)
	*/
	@SuppressWarnings("unchecked")
	@Override
	public void receive_I5_13(ArrayList<clsSuperEgoConflict> poForbiddenDrives, ArrayList<clsDriveMesh> poData,ArrayList<clsEmotion> poEmotions) {
	
		moDriveList_Input       = (ArrayList<clsDriveMesh>) deepCopy(poData);
		moForbiddenDrives_Input = (ArrayList<clsSuperEgoConflict>) deepCopy(poForbiddenDrives);
		moEmotions_Input             = clone(poEmotions);
		
	}


	private ArrayList<clsEmotion> clone(ArrayList<clsEmotion> oEmotions) {
		// deep clone: oEmotions --> oClonedEmotions
		ArrayList<clsEmotion> oClonedEmotions = new ArrayList<clsEmotion>();
		ArrayList<clsPair<clsDataStructurePA, clsDataStructurePA>> poClonedNodeList = new ArrayList<clsPair<clsDataStructurePA, clsDataStructurePA>>();
		for (clsEmotion oOneEmotion : oEmotions) {
			try {
				oClonedEmotions.add( (clsEmotion) oOneEmotion.clone(poClonedNodeList));
			} catch (CloneNotSupportedException e) {
				// Auto-generated catch block
				e.printStackTrace();
			}
		}
		
		return oClonedEmotions;
	}


	/* (non-Javadoc)
	*
	* @author gelbard
	* 15.09.2011, 16:15:00
	* 
	* @see pa.modules.clsModuleBase#process()
	*/
	@SuppressWarnings("unchecked")
	@Override
	protected void process_basic() { 
		moDriveList_Output = (ArrayList<clsDriveMesh>) deepCopy(moDriveList_Input);
		moEmotions_Output = clone(moEmotions_Input);
		
		nStep++;
		
	
		
		
		/*
		// search in list of incoming drives
		for(clsDriveMesh oDrive : moDriveList_Input){
			// check DriveMesh
			if (oDrive.getActualDriveAim().getMoContent().equals("BITE")){
				ArrayList<String> test = new ArrayList<String>();
				test.add("BITE");
				defenseMechanism_ReactionFormation(test);
				//repress_single_drive(oDrive);
				break;
			}
		}
		*/
	
				
		 
		moTimeInputChartData();
		detect_conflict_and_activate_defense_machanisms();
		
		
		
			
			
	
	}

	/* (non-Javadoc)
	 *
	 * @author gelbard
	 * 28.03.2012, 17:30:00
	 * 
	 * This function detects a psychoanalytic conflict
	 * and activates the defense mechanisms
	 * and chooses a defense mechanism to resolve the conflict.
	 *
	 */
	private void detect_conflict_and_activate_defense_machanisms() {
			
		GetCombinedTimeDefenseYaxisData();	
		
		 // If no Defense to defend return immediately (otherwise NullPointerException)
		
	   	 if (moForbiddenDrives_Input == null ) return;
		
		 // empty the list from last step otherwise list only grows
		 moQuotasOfAffect_Output.clear();
		
		 // check for a psychoanalytic conflict
		 // defense mechanisms are delayed by one cycle to produce a situation where conflict exists and no action plans are executed
		 if (!moForbiddenDrives_Input.isEmpty() && !defense_active)
		 {
			 // conflicting events exist -> activate conflict -> activate defense mechanisms but do not defend yet. (defense will work in the next cycle)
			 defense_active = true;
			 
			 // send quota of affect 999.9 via I5.17 to produce a "CONFLICT"-signal in F20
			 clsAffect oAffect = (clsAffect) clsDataStructureGenerator.generateDataStructure(eDataType.AFFECT, new clsPair<eContentType, Object>(eContentType.AFFECT, 999.9)); 
			 moQuotasOfAffect_Output.add(oAffect);
			 
			 return;
		 }
		 
		 else if (moForbiddenDrives_Input.isEmpty())
		 {
			 // no conflicting events -> deactivate defense mechanisms
			 defense_active = false;
			 return;
		 }
		 
		 // Defense mechanisms start to work.
		 
		 
		 // Super-Ego requests to defend the drives moForbiddenDrives_Input
		 // Ego decides now which defense mechanisms to apply (depending on the quota of affect of the forbidden drive)
		 
		 
		 
		 selectAndActivateDefenseMechanisms();
		 
		 
		
	
 	    // for Bar Chart and Time Chart
		moTimeInputChartData();
		GetCombinedTimeDefenseYaxisData();
	}
	
	
	private void selectAndActivateDefenseMechanisms_Lotfi() {
	 // get quota of affect of forbidden drive (for now only one forbidden drive is possible)
        // many forbidden drives possible
        
        double oQoA = getQuotaOfAffect(moForbiddenDrives_Input);
        //int Displacement=0;
       
        
        /*
         *  @author Lotfi
         *     12.12.2012, 17:30:00
         * The Defense Mechanisms are depending on Emotion "Anxiety" and Quota of Affect"
         */
        
                
       if((oQoA < 0.1)&& (GetEmotionIntensity(eEmotionType.ANXIETY) <= 0.6)){
            
                 defenseMechanism_Sublimation(moForbiddenDrives_Input);
           
                        
        }else if((oQoA < 0.1) && (GetEmotionIntensity(eEmotionType.ANXIETY) > 0.6) && (GetEmotionIntensity(eEmotionType.ANXIETY) <= 1.0)){
            
                defenseMechanism_Displacement(moForbiddenDrives_Input);
           
                        
        }else  if((oQoA < 0.1) && (GetEmotionIntensity(eEmotionType.ANXIETY) > 1.0) && (GetEmotionIntensity(eEmotionType.ANXIETY) <= 1.2)){
            
                defenseMechanism_ReactionFormation(moForbiddenDrives_Input);
            
                                   
        }else if((oQoA > 0.1) && (GetEmotionIntensity(eEmotionType.ANXIETY) > 1.2)&& (GetEmotionIntensity(eEmotionType.ANXIETY)<=1.4)){
            
                defenseMechanism_ReversalOfAffect(moForbiddenDrives_Input, 0.2);
            

                
                
        }else if((oQoA > 0.1) && (GetEmotionIntensity(eEmotionType.ANXIETY) > 1.4)&& (GetEmotionIntensity(eEmotionType.ANXIETY)<=1.6)){
        
                defenseMechanism_Turning_Against_Self (moForbiddenDrives_Input); 
                           
                // ARSIN should not hurt him self
                
                ArrayList<clsDriveMesh> oMatchingDrives = findInDriveList(moForbiddenDrives_Input);
                
                for(clsDriveMesh Drive_After_Turning_Against_Self: oMatchingDrives){
                    if(Drive_After_Turning_Against_Self.getActualDriveAim().getContent().equals("EAT")||Drive_After_Turning_Against_Self.getActualDriveAim().getContent().equals("BITE")){                 
                        Projection(Drive_After_Turning_Against_Self);
                    }
               }
   
               
                
           
//        }else if((oQoA > 0.3) && (GetEmotionIntensity(eEmotionType.ANXIETY) > 0.8)&& (GetEmotionIntensity(eEmotionType.ANXIETY)<=1.0)){
//            
           // defenseMechanism_Projection (moForbiddenDrives_Input); 

        }else if((oQoA > 0.8) && (GetEmotionIntensity(eEmotionType.ANXIETY) > 2.0)){
            
                defenseMechanism_Repression(moForbiddenDrives_Input);
            

            
        }
        else{
            // Just to see on the Simulation that no defense is done 
            
            NoDefenseIsDone();
           
       }
    
	}
	
	
   /* (non-Javadoc)
    *
    * @author gelbard
    * 12.02.2014, 10:56:00
    * 
    * This function chooses a defense mechanism depending on the conflict tension and the ego strength
    * and activates the defense mechanism.
    * - Low ego strength means a primitive defense mechanism is selected
    * - High ego strength means an elevated defense mechanism is selected
    * - If the conflict tension is high repression must no be selected because the drive wish must be satisfied
    *
    */
	private void selectAndActivateDefenseMechanisms()
	{
	    
	    double conflictTension = calculateConflictTension(moForbiddenDrives_Input); 
	    
	    // defense is only activated if there is a basic anxiety
	    if (GetEmotionIntensity(eEmotionType.ANXIETY) < 0.1) {
	        NoDefenseIsDone(); // just to see in the inspectors in the simulation that no defense is done
	        return;
	    }

	    // no defense if the forbidden drive wishes are too strong
	    if (getQuotaOfAffect(moForbiddenDrives_Input) > 0.9) {
	        NoDefenseIsDone(); // just to see in the inspectors in the simulation that no defense is done
	        return;
	    }


	    // Selection of defense mechanisms for drives depending on the conflict tension and the ego strength
	    if (conflictTension <= 0.01) {
	        NoDefenseIsDone(); // just to see in the Mason-inspectors that no defense is done
	        return;
	    }
	    
	    defenseMechanism_Displacement(moForbiddenDrives_Input);
	    
	    if (conflictTension <= 0.5) {
	        if (moEgoStrength < 0.15) { 
	            defenseMechanism_Turning_Against_Self (moForbiddenDrives_Input); 
	                                
	            // ARSIN should not hurt him self
	            
	            /* Younes Lofti:
	             *
	             * Turning against Self is defined that the new Drive Object is "Self"
	             * - Projection is defined that the new Drive Source is the old Drive Object and new Drive object is Self
	             *    Since Drive Source in ARS is Organ we use projection to protect ARSIN From  Turning against self if drive aim such as EAT and Bite
	             *  
	             */
	            ArrayList<clsDriveMesh> oMatchingDrives = findInDriveList(moForbiddenDrives_Input);
	                     
	            for(clsDriveMesh Drive_After_Turning_Against_Self: oMatchingDrives){
	                if(Drive_After_Turning_Against_Self.getActualDriveAim().getContent().equals("EAT") ||
	                   Drive_After_Turning_Against_Self.getActualDriveAim().getContent().equals("BITE"))                 
	                    Projection(Drive_After_Turning_Against_Self);
	            }
	        }
	        else if (moEgoStrength < 0.25) ;//Das ist nur für UC1 deaktiviert. Sollte man wieder aktivieren. Repression funktioniert einwandfrei. //defenseMechanism_Repression(moForbiddenDrives_Input);
	        else if (moEgoStrength < 0.35) defenseMechanism_ReactionFormation(moForbiddenDrives_Input);
	        else                           defenseMechanism_Sublimation(moForbiddenDrives_Input);
	        
	    }       
	    else {
	        if (moEgoStrength <= 0.3) {
	                // den folgenden defense mechanism gibt es noch nicht. Es muss aber nur eine Hash-tabell wie z. B. Sublimation angelegt werden.
	                // (drive aim active -> passive)
	                //defenseMechanism_ReversalIntoTheOpposite(moForbiddenDrives_Input);
	        }
	        else if (moEgoStrength <= 0.7) defenseMechanism_Displacement(moForbiddenDrives_Input);
	        else {
	                // ACHTUNG: fuer diesen Abwehrmechanismus gibt es noch kein fuktionierendes drive aim (= act)
	                // -> ist daher einstweilen nur ein dummy-Aufruf
	                defenseMechanism_Intellectualization(moForbiddenDrives_Input);
	        }
	    }       

	}
	
	
	
	
	private void NoDefenseIsDone(){
		TimePassForbiddenDrives =1.0;
		PassForbiddenDrives++;

		
	}
	
	/* (non-Javadoc)
    *
    * @author gelbard
    * 11.03.2014, 15:51:00
    * 
    * This function calculates the average conflict tension of the drives in the list of forbidden drives.
    *
    */
	private double calculateConflictTension(ArrayList<clsSuperEgoConflict> forbiddenDrives_Input) {
	    double conflictTension = 0.0;
	    int sizeOfForbiddenDrivesList = forbiddenDrives_Input.size();
	    
	    for(int i=0; i < sizeOfForbiddenDrivesList; i++) {
	        conflictTension += forbiddenDrives_Input.get(i).getConflictTension();
	    }
	    
	    return conflictTension / sizeOfForbiddenDrivesList;
	}
	
	// Search of the emotion types if they exist
	private boolean searchInEmotions (eEmotionType oEmotionType) {	
		
	   	for(clsEmotion oOneEmotion : moEmotions_Output.get(0).generateExtendedEmotions()) {
	   		if(oOneEmotion.getContent() == oEmotionType) {
	   			return true;
	   		}
	   	}
	   	
	   	return false;
	}

	// get the intensity of the emotions MOURNING, ANXIETY and ANGER 
	private double GetEmotionIntensity(eEmotionType moEmotionType){
		double oEmotionIntensity =0.0;
		for(clsEmotion oOneEmotion : moEmotions_Output.get(0).generateExtendedEmotions()) {
			
				if(searchInEmotions (eEmotionType.MOURNING)){
					if ((moEmotionType == eEmotionType.MOURNING) && (oOneEmotion.getContent() == eEmotionType.MOURNING)){
						oEmotionIntensity = oOneEmotion.getEmotionIntensity();
					}
			    }
				if(searchInEmotions (eEmotionType.ANXIETY)){
					if ((moEmotionType == eEmotionType.ANXIETY)&&(oOneEmotion.getContent() == eEmotionType.ANXIETY)){
						oEmotionIntensity = oOneEmotion.getEmotionIntensity();
					}
				}
			     
			    if(searchInEmotions(eEmotionType.ANGER)){
			    	if ((moEmotionType == eEmotionType.ANGER)&&(oOneEmotion.getContent() == eEmotionType.ANGER)){
			    		 oEmotionIntensity = oOneEmotion.getEmotionIntensity();
			    	}
			    }
	
			
		}
		return oEmotionIntensity;
	}
	
	// Just For Simulation, to remove last defense Mechanism
	
	
	
	/* (non-Javadoc)
	 *
	 * @author gelbard
	 * 21.09.2012, 15:30:00
	 * 
	 * This is a function that represents the defense mechanism "reversal of affect" for drives.
	 * Reversal of affect shifts parts of the quota of affect from the AFFECTIVE drive to the LIBIDILOUS drive (or vice versa).
	 * (The opposite drive must exist. Otherwise no Defense is changed.)
	 * @param oShiftQuotaOfAffect: oShiftQuotaOfAffect is the amount which is shifted from the quota of affect to the opposite drive
	 *
	 */
	private void defenseMechanism_ReversalOfAffect(ArrayList<clsSuperEgoConflict> oForbiddenDrives_Input, double oShiftQuotaOfAffect) {
	   	
		// If no forbidden drive in list return immediately (otherwise NullPointerException)
		// oShiftQuotaOfAffect must always be less or equal to 1, otherwise error
	   	if (oForbiddenDrives_Input == null || oShiftQuotaOfAffect > 1.0) return;
		
	    ArrayList<clsDriveMesh> oMatchingDrives = findInDriveList(oForbiddenDrives_Input);

	    if (!oMatchingDrives.isEmpty())
		   
		   // do reversal of affect for each matching drive
		   for (clsDriveMesh oOneMatchingDrive : oMatchingDrives) {
			   
			   // If the amount of the quota of affect to subtract is greater than the quota of affect minus 0.1, lower the amount to subtract.
			   // This way, the quota of affect is never lower than 0.1.
			   if (oShiftQuotaOfAffect > oOneMatchingDrive.getQuotaOfAffect() - 0.01)
			   		oShiftQuotaOfAffect = oOneMatchingDrive.getQuotaOfAffect() - 0.01;
			   
			   // subtract quota of affect from original drive
			   oOneMatchingDrive.setQuotaOfAffect(oOneMatchingDrive.getQuotaOfAffect() - oShiftQuotaOfAffect);
			   
			   clsDriveMesh oOppositeDrive = searchOppositeDrive(oOneMatchingDrive);
			   
			   if (oOppositeDrive != null) {
			       if (oOppositeDrive.getQuotaOfAffect() + oShiftQuotaOfAffect <= 1.0) {
			           oOppositeDrive.setQuotaOfAffect(oOppositeDrive.getQuotaOfAffect() + oShiftQuotaOfAffect);
			       }
			       else {
			           oOppositeDrive.setQuotaOfAffect(1.0);
			   
			           // add surplus quota of affect to affect only list
			           clsAffect oAffect = (clsAffect) clsDataStructureGenerator.generateDataStructure(eDataType.AFFECT, new clsPair<eContentType, Object>(eContentType.AFFECT, oOppositeDrive.getQuotaOfAffect() - 1.0)); 
			           moQuotasOfAffect_Output.add(oAffect);
			       }
			   }
			   
			   /*
			    * WARING: Do not create an opposite drive if it does not exist.
			    *         Maybe the opposite drive was repressed earlier by a different Super-Ego rule.
			    *         If an opposite drive is created two Super-Ego rule can be in conflict and must be defended by the defense mechanism.
			    *         
			    * das Problem beim Folgenden ist weiters: Welches DriveAim soll ich an den neuen Trieb hängen? Und welchen ePartialDrive?
	
			   else {
				   	
				   // opposite drive mesh does not exist
				   // -> generate a new opposite drive mesh in list of outgoing drives
				   
				   //create a TPM for the organ of the drive mesh
				   clsThingPresentationMesh oOrganTPM = 
					       (clsThingPresentationMesh)clsDataStructureGenerator.generateDataStructure( 
								eDataType.TPM, new clsTriple<eContentType, ArrayList<clsThingPresentation>, Object>(eContentType.ORGAN, new ArrayList<clsThingPresentation>(), "STOMACH") );
				   
				   // determine opposite drive component
				   eDriveComponent oOppositeDriveComponent;
				   if (oOneMatchingDrive.getDriveComponent().equals(eDriveComponent.AGGRESSIVE))
				       oOppositeDriveComponent = eDriveComponent.LIBIDINOUS;
				   else
					   oOppositeDriveComponent = eDriveComponent.AGGRESSIVE;

				   //create the DM
				   clsDriveMesh oNewDrive =
						   (clsDriveMesh) clsDataStructureGenerator.generateDM(
							    new clsTriple<eContentType, ArrayList<clsThingPresentationMesh>, Object>(eContentType.DRIVECANDIDATE, new ArrayList<clsThingPresentationMesh>(), ""), 
							    oOppositeDriveComponent, ePartialDrive.UNDEFINED );
					
				   //supplemental information
				   oNewDrive.setActualDriveSource(oOrganTPM, 1.0);
				   oNewDrive.setActualBodyOrifice(oOrificeTPM, 1.0);
				   oNewDrive.setQuotaOfAffect(oShiftQuotaOfAffect);
				   
				   
				   
				   // add new opposite drive mesh to list of outgoing drives
				   moDriveList_Output.add(oNewDrive);
			   }
			   
			   */
			   
		   }
	 
		 TimeReversalOfAffect=1.0;
		 ReversalOfAffect ++;
		

	}
	

	
	/* (non-Javadoc)
	 *
	 * @author gelbard
	 * 21.09.2012, 15:45:00
	 * 
	 * This is a function searches a drive with the opposite drive component.
	 * eDriveComponent can be LIBIDINOUS or AGGRESSIVE
	 *
	 */
	private clsDriveMesh searchOppositeDrive(clsDriveMesh oOriginalDrive) {
		
		   // determine opposite drive component
		   // drive component can be LIBIDINOUS or AGGRESSIVE
		   eDriveComponent oOppositeDriveComponent;
		   if (oOriginalDrive.getDriveComponent().equals(eDriveComponent.AGGRESSIVE))
		       oOppositeDriveComponent = eDriveComponent.LIBIDINOUS;
		   else
			   oOppositeDriveComponent = eDriveComponent.AGGRESSIVE;
		
		   
			// search in list of drives
			for(clsDriveMesh oDrive : moDriveList_Output){				
				if (oDrive.getDriveComponent().equals(oOppositeDriveComponent) &&
					oDrive.getActualDriveSourceAsENUM().equals(oOriginalDrive.getActualDriveSourceAsENUM())){

					// opposite drive found
				    return oDrive;
				}
			}
			
			
			// return null is no opposite drive was found
			return null;
	}
	/* (non-Javadoc)
    *
    * @author Lotfi
    * 15.05.2013, 17:30:00
    * 
    * This is a function that represents the defense mechanism "Turning_Against_Self".
    * Turning_Against_Self ----Coming soon.
    *
    */
	
	private void defenseMechanism_Turning_Against_Self (ArrayList<clsSuperEgoConflict> oForbiddenDrives_Input){
	    Turning_Against_Self ++;
	    TimeTurning_Against_Self=1.0;
	    
	    ArrayList<clsDriveMesh> oMatchingDrives = findInDriveList(oForbiddenDrives_Input);
	    if (!oMatchingDrives.isEmpty())
	           for (clsDriveMesh oOneMatchingDrive : oMatchingDrives) {
	                // remove the drive from output list              
	               moDriveList_Output.remove(oOneMatchingDrive);

                   aufbereitungInterface (oOneMatchingDrive, "Turn Against Self"); //Ivy
                   clsDriveMesh oTemp = Turning_Against_Self(oOneMatchingDrive); //Ivy
                   aufbereitungInterface(oTemp, "Turn Against Self"); //Ivy
                   
                   // insert displaced drive
                   moDriveList_Output.add(oTemp);
	           }
	    
	    
	}
	
	private clsDriveMesh Turning_Against_Self(clsDriveMesh poOriginalDM){

        //Drive_After_Turning_Against_Self= poOriginalDM;
        oOriginalDOContentForTurning_Against_Self = poOriginalDM.getActualDriveObject().getContent();
       
        //Test.add(poOriginalDM.getActualDriveSource().toString());
        //Test.add(oOriginalDOContentForTurning_Against_Self);
       // RemoveLast(Test);
        
           
//        clsThingPresentationMesh oDisplacedDriveSource = (clsThingPresentationMesh) clsDataStructureGenerator.generateDataStructure(
//                eDataType.TPM,
//                new clsTriple<eContentType, Object, Object> (eContentType.ORGAN, new ArrayList<clsThingPresentation>(), oOriginalDOContent));
        
        clsThingPresentationMesh oDisplacedDriveObject = (clsThingPresentationMesh) clsDataStructureGenerator.generateDataStructure(
                eDataType.TPM,
                new clsTriple<eContentType, Object, Object> (eContentType.ENTITY, new ArrayList<clsThingPresentation>(), eContent.SELF.toString()));
        
        
        try {
            
                    poOriginalDM.setActualDriveObject(oDisplacedDriveObject, 1.0);
            
        } catch (Exception e) {
        e.printStackTrace();
        }
        
//     Test1.add(poOriginalDM.getActualDriveObject().getMoContent().toString());
//     Test1.add(poOriginalDM.getActualDriveSource().getMoContent().toString());
//    
//      RemoveLast(Test1);
//        if(poOriginalDM.getActualDriveAim().getMoContent().equals("EAT")||poOriginalDM.getActualDriveAim().getMoContent().equals("BITE")){
//            
//            Projection(poOriginalDM);
//            
//        }
//        Test1.add(oOriginalDOContentForTurning_Against_Self.toString());
       // RemoveLast(Test1);
        //clsDriveMesh Drive_After_Turning_Against_Self1= poOriginalDM;
//        Test.add(Drive_After_Turning_Against_Self1.toString());
//        RemoveLast(Test);

        
        return poOriginalDM;
    }
	
	private void defenseMechanism_Projection(ArrayList<clsSuperEgoConflict> oForbiddenDrives_Input){
//	    Projection ++;
//        TimeProjection=1.0;

	    ArrayList<clsDriveMesh> oMatchingDrives = findInDriveList(oForbiddenDrives_Input);
        if (!oMatchingDrives.isEmpty())
               for (clsDriveMesh oOneMatchingDrive : oMatchingDrives) {

                   // remove the drive from output list              
                  moDriveList_Output.remove(oOneMatchingDrive);

                  aufbereitungInterface (oOneMatchingDrive, "Projection"); //Ivy
                  clsDriveMesh oTemp = Projection(oOneMatchingDrive); //Ivy
                  aufbereitungInterface(oTemp, "Projection"); //Ivy
                  
                  // insert displaced drive
                  moDriveList_Output.add(oTemp);
                    
               }
        
        

	}
	
	private clsDriveMesh Projection (clsDriveMesh poOriginalDM){
	    
	    Projection ++;
	    TimeProjection =1.0;
	   
	    
	   // String oOriginalDOContent = poOriginalDM.getActualDriveSource().getMoContent();
//        Test.add(oOriginalDOContent);
//        Test.add(poOriginalDM.getActualDriveSource().toString());
        //RemoveLast(Test);
        
        // to do Not eContentType.ORGAN anything else
        
//	    Test1.add(oOriginalDOContentForTurning_Against_Self.toString());
//        RemoveLast(Test1);
	    String DOContetnForProjection= new String();
	    DOContetnForProjection = oOriginalDOContentForTurning_Against_Self;
	    clsThingPresentationMesh oDisplacedDriveObject = (clsThingPresentationMesh) clsDataStructureGenerator.generateDataStructure(
                eDataType.TPM,
                new clsTriple<eContentType, Object, Object> (eContentType.ENTITY, new ArrayList<clsThingPresentation>(), DOContetnForProjection));
        
//        clsThingPresentationMesh oDisplacedDriveSource = (clsThingPresentationMesh) clsDataStructureGenerator.generateDataStructure(
//                eDataType.TPM,
        
//                new clsTriple<eContentType, Object, Object> (eContentType.ORGAN, new ArrayList<clsThingPresentation>(), eContent.SELF.toString()));
        
        try {
            //Since Drive Source in ARS is defined as Organ, Drive Source as Entity like SELF is not possible 
            
  //         poOriginalDM.setActualDriveSource(oDisplacedDriveSource,1.0);
           poOriginalDM.setActualDriveObject(oDisplacedDriveObject, 1.0);

            
        } catch (Exception e) {
        e.printStackTrace();
        }
        
        
//        Test1.add(DOContetnForProjection );
//        RemoveLast(Test1);


      
	 return poOriginalDM;
	}
	
//	 private void RemoveLast(ArrayList<String> Test){
//	        for (int i=0;i<Test.size();i++){
//	            if (i>4){
//	                Test.remove(0);
//	            }
//	            
//	        }
//	    }
//	
	
	
	/* (non-Javadoc)
	 *
	 * @author gelbard
	 * 28.03.2012, 17:30:00
	 * 
	 * This is a function that represents the defense mechanism "displacement".
	 * Displacement means that the drive object is changed.
	 *
	 */
	private void defenseMechanism_Displacement(ArrayList<clsSuperEgoConflict> oForbiddenDrives_Input) {
		
	    Displacement ++;
	    TimeDisplacement=1.0;
	
	   ArrayList<clsDriveMesh> oMatchingDrives = findInDriveList(oForbiddenDrives_Input);
	
	   if (!oMatchingDrives.isEmpty())
		   for (clsDriveMesh oOneMatchingDrive : oMatchingDrives) {
               // remove the drive from output list              
              moDriveList_Output.remove(oOneMatchingDrive);

              aufbereitungInterface (oOneMatchingDrive, "Displacement"); //Ivy
              clsDriveMesh oTemp = displacement(oOneMatchingDrive); //Ivy
              aufbereitungInterface(oTemp, "Displacement"); //Ivy
              
              // insert displaced drive
              moDriveList_Output.add(oTemp);
				
		   }
	   
	}
	
	private void defense_done(ArrayList<clsSuperEgoConflict> oForbiddenDrives_Input) {
		// Ivy-Frage: fügt er da alle gelöschten verbotenen Drives quasi wieder zurück?
		
		   ArrayList<clsDriveMesh> oMatchingDrives = findInDriveList(oForbiddenDrives_Input);
		
		   if (!oMatchingDrives.isEmpty())
			   for (clsDriveMesh oOneMatchingDrive : oMatchingDrives) {
					// remove the drive from output list
					
					// insert displaced drive
					moDriveList_Output.add(oOneMatchingDrive);
					
			   }
		
	}
	
	
	
	/* (non-Javadoc)
	*
	* @author Lotfi
	* 10.10.2012, 17:30:00
	* 
	* Helper function for the defense mechanism "displacement"
	*
	*/
	private clsDriveMesh displacement(clsDriveMesh poOriginalDM) {
		
		HashMap<String, String> oDisplaceDriveObjectList = new HashMap<String, String> ();
		
		// List Of DriveObjekt and displaced DriveObject 
		
	
		//ANIMATES
		oDisplaceDriveObjectList.put("ANIMAL","ARSIN");
		oDisplaceDriveObjectList.put("ARSIN","REMOTEBOT");	
		oDisplaceDriveObjectList.put("REMOTEBOT","ANIMAL");
		oDisplaceDriveObjectList.put("HARE","LYNX");	
		oDisplaceDriveObjectList.put("LYNX","HARE");	
		oDisplaceDriveObjectList.put("PLANT","FUNGUS_EATER");
		oDisplaceDriveObjectList.put("CAKE","SCHNIZL");
		oDisplaceDriveObjectList.put("FUNGUS_EATER","ANIMAL");
		
		
		//INANIMATE
		oDisplaceDriveObjectList.put("FUNGUS_EATER","ANIMAL");
		oDisplaceDriveObjectList.put("BASE","CAKE"); 
		oDisplaceDriveObjectList.put("CAN","BASE");
		oDisplaceDriveObjectList.put("SCHNITZL","BASE");
		oDisplaceDriveObjectList.put("STONE","WALL");
		oDisplaceDriveObjectList.put("WALL","FOOD");
		oDisplaceDriveObjectList.put("FOOD","STONE");
		oDisplaceDriveObjectList.put("FUNGUS","CARROT");
		oDisplaceDriveObjectList.put("URANIUM","SMARTEXCREMENT");
		oDisplaceDriveObjectList.put("CARROT","CAKE");
		oDisplaceDriveObjectList.put("SMARTEXCREMENT","TOILET");
		oDisplaceDriveObjectList.put("EXCREMENT","RECTANGLE_MOBILE");
		oDisplaceDriveObjectList.put("TOILET","EXCREMENT");	
		oDisplaceDriveObjectList.put("RECTANGLE_STATIONARY","SCHNITZL");
		oDisplaceDriveObjectList.put("RECTANGLE_MOBILE","CAN");
		
		//SPECIAL
		oDisplaceDriveObjectList.put("SELF","CAN");
		
		//UNREAL
		oDisplaceDriveObjectList.put("HEALTH","MINI_HEALTH");
		oDisplaceDriveObjectList.put("MINI_HEALTH","HEALTH");
		oDisplaceDriveObjectList.put("SMALL_ARMOR","UDAMAGE");
		oDisplaceDriveObjectList.put("SUPER_ARMOR","SMALL_ARMOR");
		oDisplaceDriveObjectList.put("UDAMAGE","MINI_HEALTH");
		oDisplaceDriveObjectList.put("FLAKCANNON_WEAPON","FLAKCANNON_AMMO");
		oDisplaceDriveObjectList.put("FLAKCANNON_AMMO","BIORIFLE_WEAPON");
		oDisplaceDriveObjectList.put("BIORIFLE_WEAPON","LINKGUN_WEAPON");
		oDisplaceDriveObjectList.put("BIORIFLE_AMMO","FLAKCANNON_AMMO");
		oDisplaceDriveObjectList.put("LINKGUN_WEAPON","LINKGUN_AMMO");
		oDisplaceDriveObjectList.put("LINKGUN_AMMO","BIORIFLE_WEAPON");
		oDisplaceDriveObjectList.put("MINIGUN_WEAPON","MINIGUN_AMMO");
		oDisplaceDriveObjectList.put("MINIGUN_AMMO","SNIPER_WEAPON");
		oDisplaceDriveObjectList.put("ROCKET_WEAPON","MINIGUN_AMMO");
		oDisplaceDriveObjectList.put("ROCKET_AMMO","ROCKET_WEAPON");
		oDisplaceDriveObjectList.put("SNIPER_WEAPON","SNIPER_AMMO");
		oDisplaceDriveObjectList.put("SNIPER_AMMO","ROCKET_AMMO");
		oDisplaceDriveObjectList.put("SHOCKRIFLE_WEAPON","SHOCKRIFLE_AMMO");
		oDisplaceDriveObjectList.put("SHOCKRIFLE_AMMO","SNIPER_AMMO");
		
		oDisplaceDriveObjectList.put("BODO","CAKE");
		
		String oOriginalDOContent = poOriginalDM.getActualDriveObject().getContent();
		
		// if the Drive-Object-List doesn't contain the receiving object, no defense is activated 
		if(!(oDisplaceDriveObjectList.containsKey(oOriginalDOContent))){
			
			clsThingPresentationMesh oDisplacedDriveObject = (clsThingPresentationMesh) clsDataStructureGenerator.generateDataStructure(
	               eDataType.TPM,
	               new clsTriple<eContentType, Object, Object> (eContentType.ENTITY, new ArrayList<clsThingPresentation>(), oOriginalDOContent));//
			
				try {
					poOriginalDM.setActualDriveObject(oDisplacedDriveObject, 1.0);
				} catch (Exception e) {
				e.printStackTrace();
				}
						
							
		}
		else {
			
			//  replace the Drive Object 
			
			String DisplacedDriveObject = oDisplaceDriveObjectList.get(oOriginalDOContent);
			
			clsThingPresentationMesh oDisplacedDriveObject = (clsThingPresentationMesh) clsDataStructureGenerator.generateDataStructure(
	               eDataType.TPM,
	               new clsTriple<eContentType, Object, Object> (eContentType.ENTITY, new ArrayList<clsThingPresentation>(),DisplacedDriveObject));//eContentType.ACTION
			
			// Lu Sun, 25.12.2012
	        clsThingPresentationMesh oOriginalDriveObject = poOriginalDM.getActualDriveObject(); //the orignial drive object for the forbidden drive wish
	        //oOriginalDriveObject.setMoDS_ID(-1); // produces an error
	        oDisplacedDriveObject = oOriginalDriveObject;
            oDisplacedDriveObject.setInternalAssociatedContent(new ArrayList<clsAssociation>());
            oDisplacedDriveObject.setMoContent(DisplacedDriveObject);
 
			
				try {
					poOriginalDM.setActualDriveObject(oDisplacedDriveObject, 1.0);
				} catch (Exception e) {
				e.printStackTrace();
				}
			
		}
		
		return poOriginalDM;
	}
	
	// For TimeChart And BarChart
	//
	private HashMap<String, Double>  moTimeInputChartData(){
		moTimeChartData.put("TimePassForbiddenDrives", TimePassForbiddenDrives); 
		moTimeChartData.put("TimeSublimation", TimeSublimation);
		moTimeChartData.put("TimeDisplacement", TimeDisplacement);
		moTimeChartData.put("TimeReactionFormation", TimeReactionFormation);
		moTimeChartData.put("TimeRepression", TimeRepression );
		moTimeChartData.put("TimeReversalOfAffect", TimeReversalOfAffect);
		moTimeChartData.put("PassForbiddenDrives", PassForbiddenDrives);
		moTimeChartData.put("Displacement", Displacement);
		moTimeChartData.put("Sublimation", Sublimation);
		moTimeChartData.put("ReactionFormation", ReactionFormation);
		moTimeChartData.put("Repression", Repression );
		moTimeChartData.put("ReversalOfAffect", ReversalOfAffect);
		moTimeChartData.put("Turning_Against_Self", Turning_Against_Self);
		moTimeChartData.put("TimeTurning_Against_Self", TimeTurning_Against_Self);
		moTimeChartData.put("Projection", Projection);
        moTimeChartData.put("TimeProjection", TimeProjection);
		
		return moTimeChartData;
		
	}
	
	
	private void defenseMechanism_ReactionFormation (ArrayList<clsSuperEgoConflict> oForbiddenDrives_Input){
		
		// List from eDriveContent
		oOppositeTP.put("NOURISH","BITE");
		oOppositeTP.put("BITE","NOURISH"); 
		oOppositeTP.put("DEPOSITE","REPRESS");
		oOppositeTP.put("REPRESS","DEPOSITE");
		//oOppositeTP.put("EAT","SLEEP");
        oOppositeTP.put("EAT","GIVE");
		
		//old values...
		oOppositeTP.put("EXCRETE","BREATH");
		oOppositeTP.put("SLEEP","SEXUAL_AROUSAL");
		oOppositeTP.put("BREATH","EXCRETE");
		oOppositeTP.put("RELAX","AGGRESSION");
		oOppositeTP.put("SEXUAL_AROUSAL","SLEEP");
		oOppositeTP.put("AGGRESSION","RELAX");
			
		defenseMechanism_ReactionFormation_Sublimation_Intellectualization(oForbiddenDrives_Input);
		
		 TimeReactionFormation=1.0;
		 ReactionFormation++;
	}
	
	private void defenseMechanism_Sublimation (ArrayList<clsSuperEgoConflict> oForbiddenDrives_Input){
		
		oOppositeTP.put("NOURISH","TASTE_FOOD_FOR_OTHERS");
		oOppositeTP.put("BITE","DESTROY_DANGEROUS_ANIMALS");
		oOppositeTP.put("REPRESS","GUARD_DOR");
		oOppositeTP.put("DEPOSIT","THROW_OUT_GARBAGE");

		oOppositeTP.put("EAT","DIVIDE");
        //oOppositeTP.put("EAT","SHARE");
		 
		defenseMechanism_ReactionFormation_Sublimation_Intellectualization(oForbiddenDrives_Input);
		
		// for gradual sublimation: 
		// defenceMechanismGradualSublimation(oForbiddenDrives_Input);

	
		TimeSublimation=1.0;
		Sublimation++;
	}
	
	private void defenseMechanism_Intellectualization(ArrayList<clsSuperEgoConflict> oForbiddenDrives_Input){
		
		oOppositeTP.put("NOURISH","TAKE_PART_IN_SOCIAL_ACTIVITY");
		oOppositeTP.put("BITE","MOVE_JAW_MUSCLES");	
		oOppositeTP.put("REPRESS","TRAIN_PATIENCE");
		oOppositeTP.put("DEPOSIT", "GET_RID_OF_WASTE");
		// Just for Test
		oOppositeTP.put("EAT","JUST_TO_TEST");
		
		defenseMechanism_ReactionFormation_Sublimation_Intellectualization(oForbiddenDrives_Input);
	}
	
	
	/*
	 * (non-Javadoc)
	 *
	 * @author Lotfi
	 * @since 10.10.2012 14:35:51
	 * 
	 * Helper function for Reaction Formation, Sublimation and Intellectualization
	 * all of those Defense Mechanisms have to change Drive Aim
	 * 
	 */
	private void defenseMechanism_ReactionFormation_Sublimation_Intellectualization (ArrayList<clsSuperEgoConflict> moForbiddenDrives_Input){
				
			ArrayList<clsDriveMesh> oMatchingDrives = findInDriveList(moForbiddenDrives_Input);
			
			
		if (!oMatchingDrives.isEmpty())
					
			 
			   for (clsDriveMesh oOneMatchingDrive : oMatchingDrives) {

			       moDriveList_Output.remove(oOneMatchingDrive);
			       aufbereitungInterface (oOneMatchingDrive, "Replace Drive Aim"); //Ivy

			       clsDriveMesh oTemp = replaceDriveAim(oOneMatchingDrive); //Ivy
			       aufbereitungInterface(oTemp, "Replace Drive Aim"); //Ivy
			       moDriveList_Output.add(oTemp);
			       
                                  
//                   boolean sumdi = moProcessDifference.get(1).equals(moProcessDifference.get(0));
//                   boolean sumdi2 = moProcessDifference.get(1).equals(moProcessDifference.get(1));
           
//                   clsThingPresentationMesh wuhuu3 = moProcessDifference.get(1).getActualDriveAim();//::TPM::ACTION:DIVIDE
//                   clsThingPresentationMesh wuhuu4 = moProcessDifference.get(1).getActualDriveObject();//CAKE(null:null)
//                   eOrgan wuhuu6 = moProcessDifference.get(1).getActualDriveSourceAsENUM();//STOMACH
//                   eDriveComponent wuhuu9 = moProcessDifference.get(1).getDriveComponent();//LIBIDINOUS
//                   double wuhuu10 = moProcessDifference.get(1).getQuotaOfAffect();
//                   String lala = wuhuu4.getMoContent();
//                   String lala2 = wuhuu3.getMoContent();
//                   moProcessDifference.get(1).getChartShortString();
//                   sumdi2 = sumdi;
			  }
	}
	
/*
 * Zhukova
 * Gradual sublimation update, sublimation calibration via coefficient	
 */
	
	   private void defenceMechanismGradualSublimation(ArrayList<clsSuperEgoConflict> moForbiddenDrives_Input)  {
	        
	        ArrayList<clsDriveMesh> oForbiddenDriveMeshes = findInDriveList(moForbiddenDrives_Input);
	        double coefficient = 0.5;
	        
	        if (!oForbiddenDriveMeshes.isEmpty()) {
	            for (clsDriveMesh oForbiddenDriveMesh : oForbiddenDriveMeshes) {
	                moDriveList_Output.remove(oForbiddenDriveMesh);
	                oForbiddenDriveMesh.changeExpectedQuotaOfAffectOfDrive(oForbiddenDriveMesh.getActualDriveAim().getContent(), oForbiddenDriveMesh.getActualDriveObject().getContent(), -coefficient, true);
	                oForbiddenDriveMesh.changeExpectedQuotaOfAffectOfDrive(oOppositeTP.get(oForbiddenDriveMesh.getActualDriveAim().getContent()), oForbiddenDriveMesh.getActualDriveObject().getContent(), coefficient, false);
	                oForbiddenDriveMesh.updateDriveAim();
	                moDriveList_Output.add(oForbiddenDriveMesh);
	            }
	        }
	    }
	    
	
	/**
     * DOCUMENT - insert description
     *
     * @author Jordakieva
     * @since 14.11.2013 18:53:15
     *
     * @param oOneMatchingDrive
     */
    private void aufbereitungInterface(clsDriveMesh oOneMatchingDrive, String defense) {
        
        clsChangedDrives changedDrives = new clsChangedDrives ();
        
        changedDrives.fillBeforeChange(oOneMatchingDrive.getActualDriveAim().getContent(),
                oOneMatchingDrive.getActualDriveObject().getContent(), oOneMatchingDrive.getQuotaOfAffect(), 
                oOneMatchingDrive.getChartShortString(), defense, nStep);
        
        int size = mDisplayDrives.size();
        
        if (size > 0) {
            if (mDisplayDrives.get(size - 1).getBFiller()) {
                mDisplayDrives.get(size-1).fillAfterChange(oOneMatchingDrive.getActualDriveAim().getContent(), 
                        oOneMatchingDrive.getActualDriveObject().getContent(), oOneMatchingDrive.getQuotaOfAffect());
            } else mDisplayDrives.add(changedDrives);
        } else mDisplayDrives.add(changedDrives);
    }

    /*
     * (non-Javadoc)
     *
     * @author Lotfi
     *This method changes the DriveAim, if it exists in the List otherwise no change will happen
     * since 08.11.2012 16:35:51
     *
     */
    private  clsDriveMesh replaceDriveAim(clsDriveMesh poOriginalDM){  	  
		
		// get the original Drive Aim from incoming Drive
		String oOriginalTPContent = poOriginalDM.getActualDriveAim().getContent();
	
		      
			// No change will be happen, if the Drive Aim doesn't exist in the List
			if(!(oOppositeTP.containsKey(oOriginalTPContent))){
				
						
				clsThingPresentationMesh oOppositeDriveAim = (clsThingPresentationMesh) clsDataStructureGenerator.generateDataStructure(
				eDataType.TPM,
				new clsTriple<eContentType, Object, Object> (eContentType.ACTION, new ArrayList<clsThingPresentation>(), oOriginalTPContent));
				
			try {
				poOriginalDM.setActualDriveAim(oOppositeDriveAim, 1.0);
			  } catch (Exception e) {
				
				e.printStackTrace();
			  }
			
				
			}else{
				
				// Get the the new correspondent Drive Aim from the List --> The Key of HashMap is the old Drive Aim and the value of the key is the new one 
				String oOppositeTPDriveAim = oOppositeTP.get(oOriginalTPContent);	
				
			
				
					clsThingPresentationMesh oOppositeDriveAim = (clsThingPresentationMesh) clsDataStructureGenerator.generateDataStructure(
					eDataType.TPM,
					new clsTriple<eContentType, Object, Object> (eContentType.ACTION, new ArrayList<clsThingPresentation>(),oOppositeTPDriveAim));
				try {
					
					// Set the new Drive Aim
					poOriginalDM.setActualDriveAim(oOppositeDriveAim, 1.0);
				} catch (Exception e) {
				
					e.printStackTrace();
				}
			
			}
				
		
		return poOriginalDM;
		
	}
    
	private void sendDriveToBlockedContentStorage(clsDriveMesh poDM) {
		
		// Only store the drive in blocked content storage, if there are no similar drives in blocked content storage
		if (moBlockedContentStorage.getMatchesForDrives(poDM, 0.0).isEmpty()){
				//if (!moBlockedContentStorage.existsMatch(null, poDM)) {		
					// insert DriveMesh i into BlockedContentStorage
					send_D2_3(poDM);
		}
				
	}
	
	/* (non-Javadoc)
	*
	* @author gelbard
	* 30.06.2011, 14:43:00
	* 
	* This method represents the defense mechanism "repression"
	* 
	*/
	private void defenseMechanism_Repression(ArrayList<clsSuperEgoConflict> oForbiddenDrives_Input) {
		
		// Iterate over all forbidden drives
		for (clsSuperEgoConflict oConflict : oForbiddenDrives_Input) {
				
			int i = 0;
			// search in list of incoming drives
			for(clsDriveMesh oDrive : moDriveList_Output){
				// check DriveMesh
				if (oConflict.isConflict(oDrive)) {
	
					// drive found
				    break;
				}
				
				i++;
			}
			
			
			// if drive found	
			if (i < moDriveList_Output.size()) {
				
				sendDriveToBlockedContentStorage(moDriveList_Output.get(i));				
				
				// add single quotas of affect to affect only list
				clsAffect oAffect = (clsAffect) clsDataStructureGenerator.generateDataStructure(eDataType.AFFECT, new clsPair<eContentType, Object>
	
	(eContentType.AFFECT, moDriveList_Output.get(i).getQuotaOfAffect()));
				
				moQuotasOfAffect_Output.add(oAffect);
				
				// remove DriveMesh i from output list
				moDriveList_Output.remove(i);
			}
		}
		
		 TimeRepression=1.0;
		 Repression++;			 
	}
	
	/* (non-Javadoc)
	*
	* @author gelbard
	* 30.11.2011, 14:43:00
	* 
	* This method calculates the average quota of affect of the matching drives
	* (matching drives are drives which are forbidden drives and which are element of the input drive list)
	* 
	*/
	private double getQuotaOfAffect(ArrayList<clsSuperEgoConflict> oForbiddenDrives_Input) {
		
	  double oSumOfQuotaOfAffect = 0.0;
	  int i = 0;
	  ArrayList<clsDriveMesh> oMatchingDrives = findInDriveList(oForbiddenDrives_Input);
	
	  if (!oMatchingDrives.isEmpty())
		   
		   // calculate sum of quotas of affect
		   for (clsDriveMesh oOneMatchingDrive : oMatchingDrives) {
			   i++;
			   oSumOfQuotaOfAffect += oOneMatchingDrive.getQuotaOfAffect();
		   }
			   
	  if (i==0) return 0.0;
	  else      return oSumOfQuotaOfAffect / i;
	
	}	
	
	/* (non-Javadoc)
	*
	* @author gelbard
	* 09.09.2012, 18:43:00
	* 
	* This method compares the list of input drives and the list of forbidden drives
	* It returns those drives from the input drive list which are forbidden (according to the forbidden drive list)
	* 
	*/
	private ArrayList<clsDriveMesh> findInDriveList(ArrayList<clsSuperEgoConflict> oForbiddenDrives_Input) {
		
	  ArrayList<clsDriveMesh> returnDriveList = new ArrayList<clsDriveMesh>();
	  
	  // Iterate over all forbidden drives
	  //int i=0;
		for (clsSuperEgoConflict oConflict : oForbiddenDrives_Input) {
				
			// search in list of incoming drives
			for(clsDriveMesh oDrive : moDriveList_Output){
				
				// check DriveMesh
				if (oConflict.isConflict(oDrive)) {
					
					// matching drive found
				    returnDriveList.add(oDrive);
				   /* for (int i = 0; i< returnDriveList.size();i ++){
						for (int j = i+1; j< returnDriveList.size();j ++){
							if(returnDriveList.get(i).getDriveComponent().equals(returnDriveList.get(j).getDriveComponent()) && 
								returnDriveList.get(i).getActualDriveSourceAsENUM().equals(returnDriveList.get(j).getActualDriveSourceAsENUM())){
								returnDriveList.remove(i);
								
							}
							
						}*/
				    
				//}
				
	
			}
		}
		
			
		}
		
		return returnDriveList;
	}
	
	
	/* (non-Javadoc)
	*
	* @author gelbard
	* 11.08.2009, 16:15:00
	* 
	* @see pa.modules.clsModuleBase#send()
	*/
	@Override
	protected void send() { 
	    
	    //Ivy
//	    //processList (moDriveList_Input, moDriveList_Output);
//	    ArrayList <clsDriveMesh> hallo = new ArrayList ();
//	    for (int i = 0; i < moDriveList_Input.size(); i++) {
//	        hallo.add(moDriveList_Input.get(i));	        
//	    }
//	    
//	    System.err.println(hallo);
	    
//	    ArrayList <clsDriveMesh> hallo = findInDriveList(moForbiddenDrives_Input);
//	    
//	    if (hallo.isEmpty()) System.err.println("keine :)!");
//	    else { 
//	        //System.err.println(hallo); 
//	        System.out.println(moProcessDifference); System.err.println("-----------------------------"); }
	    
		send_I5_18(moDriveList_Output);
		send_I5_17(moQuotasOfAffect_Output, moDriveList_Output);
	}
	
	/* (non-Javadoc)
	*
	* @author deutsch
	* 18.05.2010, 16:48:13
	* 
	* @see pa.interfaces.send.I1_6_send#send_I1_6(java.util.ArrayList)
	*/
	@Override
	public void send_I5_18(ArrayList<clsDriveMesh> poDriveList) {
		((I5_18_receive)moModuleList.get(8)).receive_I5_18(poDriveList);
		putInterfaceData(I5_18_send.class, poDriveList);
	}
	
	/* (non-Javadoc)
	*
	* @author deutsch
	* 18.05.2010, 16:48:13
	* 
	* @see pa.interfaces.send.I5_1_send#send_I5_1(java.util.ArrayList)
	*/
	@Override
	public void send_I5_17(ArrayList<clsPrimaryDataStructure> poAffectOnlyList, ArrayList<clsDriveMesh> poDriveList) {
		((I5_17_receive)moModuleList.get(71)).receive_I5_17(poAffectOnlyList, poDriveList);	
		putInterfaceData(I5_17_send.class, poAffectOnlyList);		
	}
	
	/* (non-Javadoc)
	*
	* @author gelbard
	* 15.09.2011, 16:48:13
	* 
	* Sends blocked drive aims (clsDriveMesh) and drive objects (clsPhysicalRepresentation) to DT2_BlockedContentStorage
	*/
	@Override
	public void send_D2_3 (clsDriveMesh poDM) {
		moBlockedContentStorage.receive_D2_3(poDM);	
		putInterfaceData(D2_3_send.class, poDM);		
	}
	
	/* (non-Javadoc)
	*
	* @author deutsch
	* 12.07.2010, 10:45:33
	* 
	* @see pa.modules.clsModuleBase#process_draft()
	*/
	@Override
	protected void process_draft() {
	    
	    nStep++;
	    
        moDriveList_Output = (ArrayList<clsDriveMesh>) deepCopy(moDriveList_Input);
        moEmotions_Output = clone(moEmotions_Input);     
        
        moTimeInputChartData();
        
        GetCombinedTimeDefenseYaxisData();  
        
        // If no Defense to defend return immediately (otherwise NullPointerException)
           
        if (moForbiddenDrives_Input == null ) {
            return;
        }
           
        moQuotasOfAffect_Output.clear();
           
        // check for a psychoanalytic conflict
        // defense mechanisms are delayed by one cycle to produce a situation where conflict exists and no action plans are executed
        if (!moForbiddenDrives_Input.isEmpty() && !defense_active)
        {
            // conflicting events exist -> activate conflict -> activate defense mechanisms but do not defend yet. (defense will work in the next cycle)
            defense_active = true;
            
            // send quota of affect 999.9 via I5.17 to produce a "CONFLICT"-signal in F20
            clsAffect oAffect = (clsAffect) clsDataStructureGenerator.generateDataStructure(eDataType.AFFECT, new clsPair<eContentType, Object>(eContentType.AFFECT, 999.9)); 
            moQuotasOfAffect_Output.add(oAffect);
            
            return;
        } else if (moForbiddenDrives_Input.isEmpty()) {
            // no conflicting events -> deactivate defense mechanisms
            defense_active = false;
            return;
        } 
                
        defenseMechanism_Sublimation(moForbiddenDrives_Input);
        
        moTimeInputChartData();
        GetCombinedTimeDefenseYaxisData();
	}
	
	/* (non-Javadoc)
	*
	* @author deutsch
	* 12.07.2010, 10:45:33
	* 
	* @see pa.modules.clsModuleBase#process_final()
	*/
	@Override
	protected void process_final() {
		// TODO (GELBARD) - Auto-generated method stub
		throw new java.lang.NoSuchMethodError();
	}
	
	/* (non-Javadoc)
	*
	* @author deutsch
	* 03.03.2011, 16:39:04
	* 
	* @see pa.modules._v38.clsModuleBase#setModuleNumber()
	*/
	@Override
	protected void setModuleNumber() {
		mnModuleNumber = Integer.parseInt(P_MODULENUMBER);
		
	}
	
	/* (non-Javadoc)
	*
	* @author deutsch
	* 15.04.2011, 13:52:57
	* 
	* @see pa.modules._v38.clsModuleBase#setDescription()
	*/
	@Override
	public void setDescription() {
		moDescription = "Based on information provided by {E7} and {E9}, this module decides which drive representations " +
				"are allowed to become (pre-)conscious and if not which defense mechanism is to be applied. These mechanisms " +
				"can split the thing presentations from their quota of affect, change the thing presentations,repress the contents " +
				"until later, attach them to other contents, and more. Examples for these mechanisms are repression, intellectualization," +
				" displacement, and sublimination ({Schuster1997}). Repressed content reappears in {F54}";
	}


	/* (non-Javadoc)
	 *
	 *@author Lotfi
	 *18.12.2012 00:37:46
	 * 
	 * @see pa._v38.interfaces.itfInspectorBarChart#getBarChartTitle()
	 */
	@Override
	public String getBarChartTitle() {
		// TODO (Lotfi) - Auto-generated method stub
		return "Defense Mechanisms";
	}
	


	/* (non-Javadoc)
	 *
	 *@author Lotfi 
	 *18.12.2012 00:37:46
	 * 
	 * @see pa._v38.interfaces.itfInspectorBarChart#getBarChartData()
	 */
	@Override
	
	public HashMap<String, Double> getBarChartData(){
		// TODO (Lotfi) - Auto-generated method stub
	
		return moTimeChartData;
	}
	
	private void GetCombinedTimeDefenseYaxisData(){
		
		if((TimeRepression==1.0)&&((TimePassForbiddenDrives == 1.0)||(TimeSublimation == 1.0)||
			(TimeDisplacement==1.0)||(TimeReversalOfAffect==1.0)||(TimeReactionFormation == 1.0)||(TimeTurning_Against_Self==1.0)||(TimeProjection==1.0))){
		  TimePassForbiddenDrives =0.0;
		  TimeSublimation=0.0;
		  TimeDisplacement=0.0;
		  TimeReversalOfAffect=0.0;
		  TimeReactionFormation=0.0;
		  TimeTurning_Against_Self=0.0;
		  TimeProjection=0.0;
		}else if((TimePassForbiddenDrives==1.0)&&((TimeRepression == 1.0)||(TimeSublimation == 1.0)||
				(TimeDisplacement==1.0)||(TimeReversalOfAffect==1.0)||(TimeReactionFormation == 1.0)||(TimeTurning_Against_Self==1.0)||(TimeProjection==1.0))){
			TimeSublimation =0.0;
			TimeRepression=0.0;
			TimeDisplacement=0.0;
			TimeReversalOfAffect=0.0;
			TimeReactionFormation=0.0;
			TimeTurning_Against_Self=0.0;
			TimeProjection=0.0;
		}else if((TimeDisplacement==1.0)&&((TimePassForbiddenDrives == 1.0)||(TimeSublimation == 1.0)||
				(TimeRepression==1.0)||(TimeReversalOfAffect==1.0)||(TimeReactionFormation == 1.0)||(TimeTurning_Against_Self==1.0)||(TimeProjection==1.0))){
			TimePassForbiddenDrives =0.0;
			TimeRepression=0.0;
			TimeSublimation=0.0;
			TimeReversalOfAffect=0.0;
			TimeReactionFormation=0.0;
			TimeTurning_Against_Self=0.0;
			TimeProjection=0.0;
		}else if((TimeReversalOfAffect==1.0)&&((TimePassForbiddenDrives == 1.0)||(TimeSublimation == 1.0)||
				(TimeDisplacement==1.0)||(TimeRepression==1.0)||(TimeReactionFormation == 1.0)||(TimeTurning_Against_Self==1.0)||(TimeProjection==1.0))){
			TimePassForbiddenDrives =0.0;
			TimeRepression=0.0;
			TimeDisplacement=0.0;
			TimeSublimation=0.0;
			TimeReactionFormation=0.0;
			TimeTurning_Against_Self=0.0;
			TimeProjection=0.0;
		}else if ((TimeReactionFormation==1.0)&&((TimePassForbiddenDrives == 1.0)||(TimeSublimation == 1.0)||
				(TimeDisplacement==1.0)||(TimeReversalOfAffect==1.0)||(TimeRepression == 1.0) ||(TimeTurning_Against_Self==1.0)||(TimeProjection==1.0))){
			TimePassForbiddenDrives =0.0;
			TimeRepression=0.0;
			TimeDisplacement=0.0;
			TimeReversalOfAffect=0.0;
			TimeSublimation=0.0;
			TimeTurning_Against_Self=0.0;
			TimeProjection=0.0;
		}else if((TimeSublimation==1.0)&&((TimePassForbiddenDrives == 1.0)||(TimeRepression == 1.0)||
				(TimeDisplacement==1.0)||(TimeReversalOfAffect==1.0)||(TimeReactionFormation == 1.0)||(TimeTurning_Against_Self==1.0)||(TimeProjection==1.0))){
			TimePassForbiddenDrives =0.0;
			TimeRepression=0.0;
			TimeDisplacement=0.0;
			TimeReversalOfAffect=0.0;
			TimeReactionFormation=0.0;
			TimeTurning_Against_Self=0.0;
			TimeProjection=0.0;
			
		}else if((TimeTurning_Against_Self==1.0)&&((TimePassForbiddenDrives == 1.0)||(TimeRepression == 1.0)||
                (TimeDisplacement==1.0)||(TimeReversalOfAffect==1.0)||(TimeReactionFormation == 1.0)||(TimeSublimation==1.0)||(TimeProjection==1.0))){
            TimePassForbiddenDrives =0.0;
            TimeRepression=0.0;
            TimeDisplacement=0.0;
            TimeReversalOfAffect=0.0;
            TimeReactionFormation=0.0;
            TimeSublimation=0.0;
            TimeProjection=0.0;
            
		}else if((TimeProjection==1.0)&&((TimePassForbiddenDrives == 1.0)||(TimeRepression == 1.0)||
                (TimeDisplacement==1.0)||(TimeReversalOfAffect==1.0)||(TimeReactionFormation == 1.0)||(TimeSublimation==1.0))||(TimeTurning_Against_Self==1.0)){
            TimePassForbiddenDrives =0.0;
            TimeRepression=0.0;
            TimeDisplacement=0.0;
            TimeReversalOfAffect=0.0;
            TimeReactionFormation=0.0;
            TimeSublimation=0.0;
            TimeTurning_Against_Self=0.0;
            
		}else{
			TimePassForbiddenDrives =0.0;
			TimeRepression=0.0;
			TimeDisplacement=0.0;
			TimeReversalOfAffect=0.0;
			TimeReactionFormation=0.0;
			TimeSublimation=0.0;
			TimeTurning_Against_Self=0.0;
			TimeProjection=0.0;
		}
		
	}

	
	
	/* (non-Javadoc)
	 *
	 * author Lotfi
	 * 19.02.2013 20:24:26
	 * 
	 * @see pa._v38.interfaces.itfInspectorCombinedTimeChart#getCombinedTimeChartAxis()
	 */
	@Override
	public String getCombinedTimeChartAxis() {
		// TODO (Lotfi) - Auto-generated method stub
		return "0 to 1";
	}


	/* (non-Javadoc)
	 *
	 * author Lotfi
	 * 19.02.2013 20:24:26
	 * 
	 * @see pa._v38.interfaces.itfInspectorCombinedTimeChart#getCombinedTimeChartData()
	 *
	 */
	@Override
	public ArrayList<ArrayList<Double>> getCombinedTimeChartData() {
		// TODO (Lotfi) - Auto-generated method stub
		ArrayList<ArrayList<Double>> oResult = new ArrayList<ArrayList<Double>>();
		//GetCombinedTimeDefenseData();
		ArrayList<Double> oSublimation =new ArrayList<Double>();
		oSublimation.add(moTimeChartData.get("TimeSublimation"));
		oResult.add(oSublimation);
		
		ArrayList<Double> oDisplacement =new ArrayList<Double>();
		oDisplacement.add(moTimeChartData.get("TimeDisplacement"));
		oResult.add(oDisplacement);
		
		ArrayList<Double> oReactionFormation =new ArrayList<Double>();
		oReactionFormation.add(moTimeChartData.get("TimeReactionFormation"));
		oResult.add(oReactionFormation);
		
		ArrayList<Double> oRepression =new ArrayList<Double>();
		oRepression.add(moTimeChartData.get("TimeRepression"));
		oResult.add(oRepression);
		
		ArrayList<Double> oReversalOfAffect =new ArrayList<Double>();
		oReversalOfAffect.add(moTimeChartData.get("TimeReversalOfAffect"));
		oResult.add(oReversalOfAffect);
		
		ArrayList<Double> oTurning_Against_Self =new ArrayList<Double>();
		oTurning_Against_Self.add(moTimeChartData.get("TimeTurning_Against_Self"));
		oResult.add(oTurning_Against_Self);
        
		 ArrayList<Double> oProjection =new ArrayList<Double>();
		 oProjection.add(moTimeChartData.get("TimeProjection"));
		 oResult.add(oProjection);
		
		ArrayList<Double> oNoDefense =new ArrayList<Double>();
		oNoDefense.add(moTimeChartData.get("TimePassForbiddenDrives"));
		oResult.add(oNoDefense);
		

			
		return oResult;
	}


	/* (non-Javadoc)
	 *
	 * @author Lotfi
	 * 19.02.2013 20:24:26
	 * 
	 * @see pa._v38.interfaces.itfInspectorCombinedTimeChart#getChartTitles()
	 * 
	 */
	@Override
	public ArrayList<String> getChartTitles() {
		// TODO (Lotfi) - Auto-generated method stub
		ArrayList<String> oResult = new ArrayList<String>();
		oResult.add("Sublimation");
		oResult.add("Displacement");
		oResult.add("ReactionFormation");
		oResult.add("Repression");
		oResult.add("ReversalOfAffect");
		oResult.add("Turning_Against_Self");
		oResult.add("Projection");
		oResult.add("PassForbiddenDrives");
		
		
		
		return oResult;
	}


	/* (non-Javadoc)
	 *
	 * @author Lotfi
	 * 19.02.2013 20:24:27
	 * 
	 * @see pa._v38.interfaces.itfInspectorCombinedTimeChart#getValueCaptions()
	 */
	@Override
	public ArrayList<ArrayList<String>> getValueCaptions() {
		// TODO (Lotfi) - Auto-generated method stub
		ArrayList<ArrayList<String>> oResult = new ArrayList<ArrayList<String>>();
		
		ArrayList<String> oSublimation = new ArrayList<String>();
		oSublimation.add("Sublimation");
		oResult.add(oSublimation);
		
		ArrayList<String> oDisplacement = new ArrayList<String>();
		oDisplacement.add("Displacement");
		oResult.add(oDisplacement);
		
		ArrayList<String> oReactionFormation = new ArrayList<String>();
		oReactionFormation.add("ReactionFormation");
		oResult.add(oReactionFormation);
		
		ArrayList<String> oRepression = new ArrayList<String>();
		oRepression.add("Repression");
		oResult.add(oRepression);
		
		ArrayList<String> oReversalOfAffect = new ArrayList<String>();
		oReversalOfAffect.add("ReversalOfAffect");
		oResult.add(oReversalOfAffect);
		
		ArrayList<String> oTurning_Against_Self = new ArrayList<String>();
		oTurning_Against_Self.add("Turning_Against_Self");
        oResult.add(oTurning_Against_Self);
        
        ArrayList<String> oProjection = new ArrayList<String>();
        oProjection.add("Projection");
        oResult.add(oProjection);
		
		ArrayList<String> oNoDefense = new ArrayList<String>();
		oNoDefense.add("PassForbiddenDrives");
		oResult.add(oNoDefense);

		return oResult;
	}


    /* (non-Javadoc)
     *
     * @since 14.11.2013 19:18:37
     * 
     * @see pa._v38.interfaces.itfInspectorModificationDrives#processList()
     */
    @Override
    public ArrayList<clsChangedDrives> processList() {

        return mDisplayDrives;
    }


    /* (non-Javadoc)
     *
     * @since 20.02.2014 11:04:28
     * 
     * @see modules.interfaces.I5_22_receive#receive_I5_22(double)
     */
    @Override
    public void receive_I5_22(double neutralisationFactor, double neutralizedIntensity) {
        //moEgoStrength = poEgoStrength;
    }
	
}
	
